<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>MOSAIC</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#000000" />
  <style>
    :root { --bg:#000; --frame:#000; --paper:#f2efe6; }
    html,body { margin:0; height:100%; background:#000; }
    #app { position:relative; width:100vw; height:100svh; overflow:hidden;
           touch-action:none; -webkit-tap-highlight-color:transparent;
           padding:env(safe-area-inset-top) env(safe-area-inset-right)
                    env(safe-area-inset-bottom) env(safe-area-inset-left); }

    /* Canvas centering */
    .stage { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:var(--bg); }
    canvas { display:block; image-rendering: pixelated; }

    /* 90s TV prompt + legend */
    @font-face { font-family: VT323; src: local("VT323"); font-display: swap; }
    .tv {
      position:absolute; left:50%; transform:translateX(-50%);
      bottom:18px; background:var(--paper); color:#111;
      font-family:VT323, "Lucida Console", monospace; font-size:22px;
      box-shadow:0 0 0 3px #000, 0 0 0 6px #fff, 0 0 0 9px #000; overflow:hidden;
    }
    .tv .inner { display:flex; align-items:center; padding:10px 12px; }
    .tv.opening { animation:tv-open .22s ease-out forwards; transform-origin:50% 50%; }
    .tv.closing { animation:tv-close .22s ease-in forwards; transform-origin:50% 50%; }
    @keyframes tv-open { 0%{transform:translateX(-50%) scaleY(.02)} 60%{transform:translateX(-50%) scaleY(1.08)} 100%{transform:translateX(-50%) scaleY(1)} }
    @keyframes tv-close { 0%{transform:translateX(-50%) scaleY(1)} 100%{transform:translateX(-50%) scaleY(.02)} }
    .in { background:#fff; border:2px solid #000; padding:4px 6px; font:inherit; font-size:22px; min-width:180px; }
    .btn { margin-left:8px; background:#fff; border:2px solid #000; padding:4px 10px; font:inherit; font-size:22px; cursor:pointer; }

    /* Word overlay */
    .cover { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; }
    .cover span { font-family:VT323,"Lucida Console",monospace; font-size:min(14vw,14vh); color:#fff; letter-spacing:.06em; text-shadow:0 2px 0 rgba(0,0,0,.6); }

    /* Top-right tools: tab + tray */
    .dock { position:fixed; top:calc(12px + env(safe-area-inset-top)); right:calc(12px + env(safe-area-inset-right));
            display:flex; gap:8px; z-index:5; }
    .tab {
      width:44px; height:44px; background:#fff; border:2px solid #000;
      box-shadow:0 0 0 3px #000, 0 0 0 6px #fff, 0 0 0 9px #000;
      display:flex; align-items:center; justify-content:center;
      font-family:VT323,"Lucida Console",monospace; cursor:pointer; user-select:none;
    }
    .tray {
      background:#fff; border:2px solid #000;
      box-shadow:0 0 0 3px #000, 0 0 0 6px #fff, 0 0 0 9px #000;
      padding:6px; display:flex; flex-direction:column; gap:8px;
      transform:translateX(120%); opacity:0; transition:transform .18s ease, opacity .18s ease;
    }
    .tray.open { transform:translateX(0); opacity:1; }
    .q {
      width:40px; height:40px; background:#fff; border:2px solid #000;
      display:flex; align-items:center; justify-content:center;
      font-family:VT323,"Lucida Console",monospace; cursor:pointer; user-select:none;
    }
    @media (max-width:480px) { .q{width:36px;height:36px;font-size:18px} .tab{width:40px;height:40px} }

    /* Legend card (toggled with M or the ? in the tray) */
    .legend { position:fixed; right:calc(12px + env(safe-area-inset-right));
              top:calc(70px + env(safe-area-inset-top)); width:min(320px,80vw); }
  </style>
</head>
<body>
  <div id="app">
    <div class="stage"><canvas id="c"></canvas></div>

    <!-- TV prompt (hidden by default) -->
    <form id="prompt" class="tv" style="display:none;">
      <div class="inner">
        <span style="margin-right:8px">Seed:</span>
        <input id="seedIn" class="in" placeholder="type a wordâ€¦" />
        <button class="btn" type="submit">SET</button>
      </div>
    </form>

    <!-- Right tools -->
    <div class="dock" id="dock">
      <button class="tab" id="tabBtn">?</button>
      <div class="tray" id="tray">
        <button class="q" id="seedBtn" title="Seed (/)">/</button>
        <button class="q" id="palBtn"  title="Palette (P)">ðŸŽ¨</button>
        <button class="q" id="bgBtn"   title="Background (B)">â–¦</button>
        <button class="q" id="expBtn"  title="Export (E)">â‡©</button>
        <button class="q" id="rstBtn"  title="Reset (R)">â†º</button>
        <button class="q" id="legBtn"  title="Help (M)">?</button>
      </div>
    </div>

    <!-- Legend -->
    <div class="tv legend" id="legend" style="display:none;">
      <div class="inner" style="display:block">
        <div style="font-weight:700;margin-bottom:6px">Legend</div>
        <div style="display:grid;grid-template-columns:max-content 1fr;gap:3px 10px;font-family:VT323,'Lucida Console',monospace;font-size:20px">
          <div>Drag</div><div>paint tiles</div>
          <div>[ / ]</div><div>brush size</div>
          <div>+ / âˆ’</div><div>density (Shift = big)</div>
          <div>/</div><div>open seed prompt</div>
          <div>Enter</div><div>shuffle colors</div>
          <div>Space</div><div>hold: reveal word</div>
          <div>P / B</div><div>palette / background</div>
          <div>S</div><div>assoc mode (Semantic/Deterministic)</div>
          <div>E / R</div><div>export PNG / reset</div>
          <div style="grid-column:1 / span 2; margin-top:6px; opacity:.8">
            Mobile: drag â€¢ double-tap â€¢ long-press â€¢ pinch
          </div>
        </div>
      </div>
    </div>

    <!-- Word overlay -->
    <div id="cover" class="cover" style="display:none;"><span id="coverWord"></span></div>
  </div>

  <script>
  (function(){
    // ---------- helpers ----------
    const clamp=(n,a,b)=>Math.max(a,Math.min(b,n));
    const clean=s=>s.toLowerCase().replace(/[^a-z]/g,'');
    const hash=s=>{let h=0;for(let i=0;i<s.length;i++) h=(h*31+s.charCodeAt(i))|0; return Math.abs(h)};
    const randNext=(from)=>{let n=from; while(n===from) n=`rgb(${(Math.random()*256)|0},${(Math.random()*256)|0},${(Math.random()*256)|0})`; return n};

    // ---------- constants & state ----------
    const BGs=["#000","#808080","#fff"]; let bgIdx=0;
    const PALETTES=[
      null, // Random
      ["#ff006e","#fb5607","#ffbe0b","#3a86ff","#00f5d4","#9b5de5"],
      ["#ffd6a5","#caffbf","#bdb2ff","#a0c4ff","#ffc6ff","#f1fa8c"],
      ["#0ea5e9","#22d3ee","#06b6d4","#34d399","#60a5fa","#818cf8"],
      ["#111","#1f1f1f","#2f2f2f","#3f3f3f","#6b7280","#9ca3af","#e5e7eb","#fff"]
    ];
    let palIdx=0;
    const MIN=1, MAX=200, MINB=0, MAXB=6;
    const STORE="mosaic_state_v3";

    const FALLBACK=["anchor","bridge","spark","focus","flow","balance","portal","pixel","canvas","grid",
                    "thread","north","open","quiet","bold","soft","steady","swift","adapt","guide",
                    "seed","bloom","river","stone","ember","pulse","weave","pivot","center","root",
                    "branch","tide","frame","echo","wave","light","shade","tone","idea","sketch"];

    const state = (()=>{
      try { return JSON.parse(localStorage.getItem(STORE)||"null")||{} } catch { return {} }
    })();

    let cols = state.cols ?? 20;
    let rows = state.rows ?? 20;
    let brush = state.brush ?? 1;
    let seed  = state.seed  ?? "trust";
    let assoc = state.assoc ?? "flow";
    let mode  = state.mode  ?? "sem"; // 'sem' or 'det'
    bgIdx = state.bg ?? 0;
    palIdx = state.pal ?? 0;

    const save=()=>{ try{
      localStorage.setItem(STORE, JSON.stringify({cols,rows,brush,seed,assoc,mode,bg:bgIdx,pal:palIdx,colors}))
    }catch{} };

    // ---------- word pool ----------
    let WORDS = null;
    fetch("https://raw.githubusercontent.com/first20hours/google-10000-english/master/20k.txt")
      .then(r=>r.text()).then(t=>{
        WORDS = t.split(/\r?\n/).map(clean).filter(w=>w && w.length>2 && w.length<13);
      }).catch(()=>{ WORDS = FALLBACK; });

    const assocPick=(s,pool)=>!s?pool[0]:pool[hash(s)%pool.length];

    async function pickAssoc(seedWord){
      const s = clean(seedWord);
      if(!WORDS) return assocPick(s,FALLBACK);
      try{
        const get = u=>fetch(u,{cache:'no-store'}).then(r=>r.json());
        const [ml,syn,trg] = await Promise.all([
          get(`https://api.datamuse.com/words?ml=${encodeURIComponent(s)}&max=60`),
          get(`https://api.datamuse.com/words?rel_syn=${encodeURIComponent(s)}&max=40`),
          get(`https://api.datamuse.com/words?rel_trg=${encodeURIComponent(s)}&max=40`)
        ]);
        const seen=new Map();
        const add=(arr,w)=>arr?.forEach(d=>{
          const w0=clean(d.word||"");
          if(!w0 || !WORDS.includes(w0) || w0===s) return;
          seen.set(w0, Math.max(seen.get(w0)||0, (d.score||0)+w));
        });
        add(syn,1000); add(ml,700); add(trg,200);
        let best="", bv=-1;
        for(const [k,v] of seen){ const L=k.length; const r=v+(L>=4&&L<=10?40:0); if(r>bv){bv=r;best=k} }
        return best || assocPick(s,WORDS);
      }catch{
        return assocPick(s, WORDS||FALLBACK);
      }
    }

    // ---------- palette picker ----------
    const picker = ()=> {
      const palette = PALETTES[palIdx];
      if(!palette) return (from)=>randNext(from);
      return (from)=>{
        let n = palette[(Math.random()*palette.length)|0];
        if(n===from){ for(let i=0;i<2&&n===from;i++) n=palette[(Math.random()*palette.length)|0];
          if(n===from) n=palette[(palette.indexOf(from)+1)%palette.length];
        }
        return n;
      };
    };

    // ---------- canvas + grid ----------
    const app = document.getElementById('app');
    const stage = document.querySelector('.stage');
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    let colors = Array.from({length: cols*rows}, ()=>picker()("rgb(0,0,0)"));
    if (Array.isArray(state.colors) && state.colors.length === cols*rows) colors = state.colors.slice();

    const OVER=1;
    function sizeToFit(){
      const w = innerWidth, h = innerHeight;
      const t = Math.max(1, Math.min((w/cols)|0, (h/rows)|0));
      const W = t*cols, H = t*rows;
      canvas.width = W * devicePixelRatio;
      canvas.height = H * devicePixelRatio;
      canvas.style.width = W + "px";
      canvas.style.height = H + "px";
      ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
      ctx.imageSmoothingEnabled = false;
      document.documentElement.style.setProperty("--bg", BGs[bgIdx]);
      drawAll(t,W,H);
      return {tile:t,W,H};
    }

    function drawAll(tile,W,H){
      ctx.fillStyle = BGs[bgIdx];
      ctx.fillRect(0,0,W,H);
      let i=0;
      for(let y=0;y<rows;y++)
        for(let x=0;x<cols;x++){
          ctx.fillStyle = colors[i++];
          ctx.fillRect(x*tile, y*tile, tile+OVER, tile+OVER); // seam-free
        }
    }

    let geom=sizeToFit(); // {tile, W, H}

    addEventListener('resize', ()=>{ geom=sizeToFit(); });

    // ---------- paint + flip animation ----------
    const active = new Set(); // indices flipping now
    const flips = []; // {i,x,y,oc,nc,start}
    let animRAF = 0;

    function loop(){
      animRAF = 0;
      const {tile,W,H} = geom;
      const now = performance.now();
      let more=false;
      for(let k=flips.length-1;k>=0;k--){
        const f=flips[k];
        let t = (now - f.start)/220; if(t>1) t=1;
        const e = t<.5?2*t*t:1-(((-2*t+2)**2)/2);
        const ang = e*Math.PI;
        const cA = Math.cos(ang), sY = Math.abs(cA);
        const face = cA>=0 ? f.oc : f.nc;

        ctx.fillStyle = BGs[bgIdx];
        ctx.fillRect(f.x*tile, f.y*tile, tile+OVER, tile+OVER);

        ctx.save();
        ctx.translate(f.x*tile, f.y*tile + tile/2);
        ctx.transform(1,0,0,sY,0,0);
        ctx.translate(0,-tile/2);
        ctx.fillStyle = face;
        ctx.fillRect(0,0,tile,tile);
        const shade=.18*(1-sY);
        if(shade>0){ ctx.globalAlpha=shade; ctx.fillStyle='#000'; ctx.fillRect(0,0,tile,tile); ctx.globalAlpha=1; }
        ctx.restore();

        if(t>=1){
          colors[f.i]=f.nc;
          ctx.fillStyle=f.nc; ctx.fillRect(f.x*tile,f.y*tile,tile+OVER,tile+OVER);
          active.delete(f.i); flips.splice(k,1); save();
        } else more=true;
      }
      if(more) animRAF = requestAnimationFrame(loop);
    }

    function startFlip(i,x,y){
      const {tile} = geom;
      const oc = colors[i], nc = picker()(oc);
      if(tile<=1){ colors[i]=nc; ctx.fillStyle=nc; ctx.fillRect(x*tile,y*tile,tile+OVER,tile+OVER); save(); return; }
      if(active.has(i)) return;
      active.add(i);
      flips.push({i,x,y,oc,nc,start:performance.now()});
      if(!animRAF) animRAF=requestAnimationFrame(loop);
    }

    let dragging=false; let brushR=brush;
    let pRAF=0, queued=null;
    function schedule(x,y){
      queued={x,y};
      if(!pRAF) pRAF=requestAnimationFrame(()=>{
        pRAF=0;
        const r = canvas.getBoundingClientRect();
        const cx = (((queued.x-r.left)/r.width)*cols)|0;
        const cy = (((queued.y-r.top)/r.height)*rows)|0;
        const rad = clamp(brushR,MINB,MAXB);
        for(let dy=-rad;dy<=rad;dy++)
          for(let dx=-rad;dx<=rad;dx++){
            if(dx*dx+dy*dy>rad*rad) continue;
            const x2=cx+dx, y2=cy+dy;
            if(x2<0||y2<0||x2>=cols||y2>=rows) continue;
            startFlip(y2*cols+x2, x2, y2);
          }
      });
    }

    canvas.addEventListener('pointerdown', e=>{ dragging=true; schedule(e.clientX,e.clientY); });
    canvas.addEventListener('pointermove', e=>{ if(dragging) schedule(e.clientX,e.clientY); });
    addEventListener('pointerup', ()=>{ dragging=false; });

    // ---------- shuffle (Enter) ----------
    addEventListener('mosaic-refresh', ()=>{
      const pick = picker();
      const prev = colors.slice();
      const total = cols*rows;
      colors = Array.from({length: total}, (_,i)=> pick(prev[i%prev.length]||"rgb(0,0,0)"));
      geom=sizeToFit(); save();
    });

    // ---------- background ----------
    function setBG(i){ bgIdx=(i+BGs.length)%BGs.length; document.documentElement.style.setProperty("--bg", BGs[bgIdx]); geom=sizeToFit(); save(); }

    // ---------- export ----------
    function exportPNG(){
      const t=12, w=cols*t, h=rows*t;
      const c=document.createElement('canvas'); c.width=w; c.height=h;
      const x=c.getContext('2d'); x.fillStyle=BGs[bgIdx]; x.fillRect(0,0,w,h);
      let i=0; for(let y=0;y<rows;y++) for(let xx=0;xx<cols;xx++){ x.fillStyle=colors[i++]; x.fillRect(xx*t,y*t,t+2,t+2); }
      const a=document.createElement('a'); a.href=c.toDataURL('image/png'); a.download=`mosaic-${cols}x${rows}.png`; a.click();
    }

    // ---------- prompt (TV) ----------
    const prompt = document.getElementById('prompt');
    const seedIn = document.getElementById('seedIn');

    function openPrompt(){ prompt.style.display='block'; prompt.classList.remove('closing'); prompt.classList.add('opening'); requestAnimationFrame(()=>{ seedIn.focus(); seedIn.select(); }); }
    function closePrompt(){ prompt.classList.remove('opening'); prompt.classList.add('closing'); setTimeout(()=>{ prompt.style.display='none'; }, 180); canvas.focus?.(); }
    prompt.addEventListener('submit', async (e)=>{
      e.preventDefault();
      const v = clean(seedIn.value||"").trim();
      if(v){ seed=v; if(mode==='sem') assoc = await pickAssoc(seed); else assoc = assocPick(seed, WORDS||FALLBACK); save(); }
      closePrompt();
    });
    prompt.addEventListener('keydown', e=>{
      e.stopPropagation();
      if(e.key==='Enter'){ e.preventDefault(); prompt.requestSubmit(); }
      if(e.key==='/' || e.key==='?'){ e.preventDefault(); seedIn.select(); }
      if(e.key==='Escape'){ e.preventDefault(); closePrompt(); }
    });

    // ---------- cover (Space) ----------
    const cover = document.getElementById('cover');
    const coverWord = document.getElementById('coverWord');
    function showCover(){ cover.style.display='flex'; cover.style.background = randNext(cover.style.background||"rgb(0,0,0)"); coverWord.textContent = assoc; }
    function hideCover(){ cover.style.display='none'; }

    // ---------- keyboard ----------
    addEventListener('keydown', async e=>{
      const typing = document.activeElement && (['INPUT','TEXTAREA'].includes(document.activeElement.tagName) || document.activeElement.isContentEditable);
      if(typing) return; // prompt handles its own keys

      const step = e.shiftKey?5:1;
      if(e.code==='Space'){ e.preventDefault(); showCover(); return; }
      if(e.key==='+'||e.key==='='){ e.preventDefault(); cols=clamp(cols+step,MIN,MAX); rows=clamp(rows+step,MIN,MAX); colors.length=cols*rows; colors=Array.from({length:cols*rows},()=>picker()("rgb(0,0,0)")); geom=sizeToFit(); save(); return; }
      if(e.key==='-'||e.key==='_'){ e.preventDefault(); cols=clamp(cols-step,MIN,MAX); rows=clamp(rows-step,MIN,MAX); colors.length=cols*rows; colors=Array.from({length:cols*rows},()=>picker()("rgb(0,0,0)")); geom=sizeToFit(); save(); return; }
      if(e.key==='['){ e.preventDefault(); brushR=brush=clamp(brush-1,MINB,MAXB); save(); return; }
      if(e.key===']'){ e.preventDefault(); brushR=brush=clamp(brush+1,MINB,MAXB); save(); return; }
      if(e.key.toLowerCase()==='p'){ e.preventDefault(); palIdx=(palIdx+1)%PALETTES.length; save(); return; }
      if(e.key.toLowerCase()==='b'){ e.preventDefault(); setBG(bgIdx+1); return; }
      if(e.key.toLowerCase()==='e'){ e.preventDefault(); exportPNG(); return; }
      if(e.key.toLowerCase()==='r'){ e.preventDefault(); localStorage.removeItem(STORE); location.reload(); return; }
      if(e.key.toLowerCase()==='s'){ e.preventDefault(); mode = mode==='sem'?'det':'sem'; if(mode==='sem') assoc = await pickAssoc(seed); else assoc = assocPick(seed, WORDS||FALLBACK); save(); return; }
      if(e.key==='/'||e.key==='?'){ e.preventDefault(); openPrompt(); return; }
      if(e.key==='Enter'){ e.preventDefault(); dispatchEvent(new Event('mosaic-refresh')); return; }
      if(e.key==='Escape'){ e.preventDefault(); hideCover(); return; }
      if(e.key.toLowerCase()==='m'){ e.preventDefault(); const L=document.getElementById('legend'); const on=L.style.display!=='none'; L.style.display=on?'none':'block'; return; }
    });
    addEventListener('keyup', e=>{ if(e.code==='Space') { e.preventDefault(); hideCover(); } });

    // ---------- mobile gestures ----------
    let lastTap=0, longTimer=0, moveAmt=0;
    const touchPts=new Map(), pinchLen={val:null};
    canvas.addEventListener('pointerdown', e=>{
      dragging=true; schedule(e.clientX,e.clientY);
      if(e.pointerType==='touch'){
        const now=performance.now();
        if(now-lastTap<280) dispatchEvent(new Event('mosaic-refresh'));
        lastTap=now; clearTimeout(longTimer); moveAmt=0;
        longTimer=setTimeout(showCover, 450);
        touchPts.set(e.pointerId,{x:e.clientX,y:e.clientY});
        if(touchPts.size===2){
          const a=[...touchPts.values()];
          pinchLen.val=Math.hypot(a[0].x-a[1].x,a[0].y-a[1].y);
        }
      }
    });
    canvas.addEventListener('pointermove', e=>{
      if(!dragging) return;
      schedule(e.clientX,e.clientY);
      if(e.pointerType==='touch'){
        const p=touchPts.get(e.pointerId); if(!p) return;
        moveAmt += Math.abs(e.clientX-p.x)+Math.abs(e.clientY-p.y);
        if(moveAmt>12) clearTimeout(longTimer);
        touchPts.set(e.pointerId,{x:e.clientX,y:e.clientY});
        if(touchPts.size===2){
          const a=[...touchPts.values()];
          const d=Math.hypot(a[0].x-a[1].x,a[0].y-a[1].y);
          if(pinchLen.val){
            const r=d/pinchLen.val;
            if(r>1.06){ cols=clamp(cols+1,MIN,MAX); rows=clamp(rows+1,MIN,MAX); geom=sizeToFit(); }
            else if(r<0.94){ cols=clamp(cols-1,MIN,MAX); rows=clamp(rows-1,MIN,MAX); geom=sizeToFit(); }
            pinchLen.val=d;
          }else pinchLen.val=d;
        }
      }
    });
    addEventListener('pointerup', e=>{
      dragging=false; clearTimeout(longTimer); moveAmt=0;
      touchPts.delete(e.pointerId); if(touchPts.size<2) pinchLen.val=null;
      if(cover.style.display!=='none' && touchPts.size===0) hideCover();
    });

    // ---------- dock/top-right controls ----------
    const tray = document.getElementById('tray');
    const tabBtn = document.getElementById('tabBtn');
    tabBtn.addEventListener('click', ()=> tray.classList.toggle('open'));
    document.getElementById('seedBtn').onclick = openPrompt;
    document.getElementById('palBtn').onclick  = ()=>{ palIdx=(palIdx+1)%PALETTES.length; save(); };
    document.getElementById('bgBtn').onclick   = ()=> setBG(bgIdx+1);
    document.getElementById('expBtn').onclick  = exportPNG;
    document.getElementById('rstBtn').onclick  = ()=>{ localStorage.removeItem(STORE); location.reload(); };
    document.getElementById('legBtn').onclick  = ()=>{ const L=document.getElementById('legend'); const on=L.style.display!=='none'; L.style.display=on?'none':'block'; };

    // initial paint
    sizeToFit(); save();
  })();
  </script>
</body>
</html>
